pipeline {
    agent any
    
    parameters {
        choice(
            name: 'TEST_MODE',
            choices: ['auto', 'force_approval', 'skip_secrets', 'test_secrets'],
            description: 'Testing mode for pipeline behavior'
        )
    }
    
    environment {
        BRANCH_NAME = "${env.GIT_BRANCH ?: 'main'}"
        PR_AUTHOR = "${env.CHANGE_AUTHOR ?: env.BUILD_USER_ID ?: 'unknown'}"
        PIPELINE_STATUS = "pending"
    }
    
    stages {
        stage('PR Ready to Main') {
            steps {
                script {
                    echo "üöÄ PR Ready to Main - Pipeline Started"
                    echo "====================================="
                    echo "üìã Pipeline Information:"
                    echo "  Branch: ${env.BRANCH_NAME}"
                    echo "  Author: ${env.PR_AUTHOR}"
                    echo "  Build: #${env.BUILD_NUMBER}"
                    echo "  Test Mode: ${params.TEST_MODE}"
                    echo "====================================="
                    
                    // Checkout code
                    checkout scm
                    
                    // Get commit info
                    try {
                        def commitInfo = sh(
                            script: "git log -1 --pretty=format:'%an|%s'",
                            returnStdout: true
                        ).trim().split('\\|')
                        
                        env.COMMIT_AUTHOR = commitInfo[0]
                        env.COMMIT_MESSAGE = commitInfo[1]
                        
                        echo "üìù Latest Commit:"
                        echo "  Author: ${env.COMMIT_AUTHOR}"
                        echo "  Message: ${env.COMMIT_MESSAGE}"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Could not get commit info: ${e.message}"
                    }
                    
                    // Show repository contents for debugging
                    echo "üìÅ Repository Contents:"
                    sh 'ls -la'
                }
            }
        }
        
        stage('Check the Secrets') {
            steps {
                script {
                    echo "üîç Check the Secrets - Scanning Repository"
                    echo "========================================"
                    
                    if (params.TEST_MODE == 'skip_secrets') {
                        echo "üß™ TEST MODE: Skipping secret scanning"
                        env.SECRETS_STATUS = "not_found"
                        return
                    }
                    
                    // List files being scanned
                    echo "üìÑ Files to scan:"
                    sh 'find . -type f -not -path "./.git/*" -not -name "Jenkinsfile*" | head -20'
                    
                    // Define secret patterns to detect
                    def secretPatterns = [
                        'password\\s*[:=]\\s*["\']?[^\\s"\']{3,}',
                        'api[_-]?key\\s*[:=]\\s*["\']?[^\\s"\']{10,}',
                        'secret\\s*[:=]\\s*["\']?[^\\s"\']{6,}',
                        'token\\s*[:=]\\s*["\']?[^\\s"\']{10,}',
                        'aws[_-]?access[_-]?key\\s*[:=]\\s*["\']?[A-Z0-9]{16,}',
                        'sk-[a-zA-Z0-9]{20,}',     // OpenAI API keys
                        'ghp_[a-zA-Z0-9]{36}',     // GitHub tokens
                        'BEGIN\\s+PRIVATE\\s+KEY', // Private keys
                        '[a-fA-F0-9]{32,}',        // Hex strings (potential keys)
                        '[A-Za-z0-9+/]{40,}={0,2}' // Base64 strings (potential keys)
                    ]
                    
                    def foundSecrets = false
                    def secretDetails = []
                    
                    // Check each pattern
                    for (pattern in secretPatterns) {
                        try {
                            def result = sh(
                                script: """
                                    grep -r -i -E '${pattern}' . \\
                                        --exclude-dir=.git \\
                                        --exclude='*.log' \\
                                        --exclude='Jenkinsfile*' \\
                                        --exclude-dir=.jenkins \\
                                        --max-count=5 \\
                                        2>/dev/null || true
                                """,
                                returnStdout: true
                            ).trim()
                            
                            if (result) {
                                echo "üö® SECRET DETECTED - Pattern: ${pattern}"
                                echo "üìç Location: ${result}"
                                foundSecrets = true
                                secretDetails.add("Pattern: ${pattern} | Location: ${result}")
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è Error checking pattern ${pattern}: ${e.message}"
                        }
                    }
                    
                    // Special check for common secret files
                    def secretFiles = ['config.txt', 'secrets.txt', '.env', 'credentials.json']
                    for (file in secretFiles) {
                        if (fileExists(file)) {
                            echo "üîç Checking suspicious file: ${file}"
                            try {
                                def content = readFile(file)
                                echo "üìÑ ${file} content preview: ${content.take(200)}..."
                                
                                if (content.toLowerCase().contains('key') || 
                                    content.toLowerCase().contains('secret') || 
                                    content.toLowerCase().contains('password') ||
                                    content.toLowerCase().contains('token')) {
                                    echo "üö® SUSPICIOUS CONTENT in ${file}"
                                    foundSecrets = true
                                    secretDetails.add("Suspicious file: ${file}")
                                }
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è Could not read ${file}: ${e.message}"
                            }
                        }
                    }
                    
                    echo "========================================"
                    
                    if (foundSecrets) {
                        echo "‚ùå SECRETS FOUND - Setting status to 'found'"
                        env.SECRETS_STATUS = "found"
                        env.SECRET_DETAILS = secretDetails.join(' | ')
                        echo "üö® Secret Details: ${env.SECRET_DETAILS}"
                    } else {
                        echo "‚úÖ NO SECRETS DETECTED - Setting status to 'not_found'"
                        env.SECRETS_STATUS = "not_found"
                    }
                    
                    echo "üîç Secrets Check Complete: ${env.SECRETS_STATUS}"
                }
            }
        }
        
        stage('PR Reject') {
            when {
                expression { env.SECRETS_STATUS == "found" }
            }
            steps {
                script {
                    echo "‚ùå PR REJECT - Secrets Detected"
                    echo "=============================="
                    echo "üö® This PR cannot be merged due to exposed secrets!"
                    echo "üìã Secret Details: ${env.SECRET_DETAILS}"
                    echo "üîß Action Required:"
                    echo "   1. Remove all secrets from your code"
                    echo "   2. Use environment variables or secure vaults"
                    echo "   3. Commit the cleaned code"
                    echo "   4. Re-run the pipeline"
                    echo "=============================="
                    
                    env.PIPELINE_STATUS = "rejected_secrets"
                    
                    // Create rejection report
                    writeFile(
                        file: 'SECRET_SCAN_REPORT.txt',
                        text: """
SECRET SCAN REJECTION REPORT
===========================
Date: ${new Date()}
Branch: ${env.BRANCH_NAME}
Build: #${env.BUILD_NUMBER}
Author: ${env.COMMIT_AUTHOR}

SECRETS DETECTED:
${env.SECRET_DETAILS}

ACTION REQUIRED:
- Remove all secrets from code
- Use environment variables or secure storage
- Commit cleaned code and retry

This PR is automatically rejected for security reasons.
                        """
                    )
                    
                    error("‚ùå PR REJECTED: Secrets detected in repository")
                }
            }
        }
        
        stage('Not Found') {
            when {
                expression { env.SECRETS_STATUS == "not_found" }
            }
            steps {
                script {
                    echo "‚úÖ Not Found - No Secrets Detected"
                    echo "================================="
                    echo "üéâ Security scan passed!"
                    echo "‚úÖ No secrets found in repository"
                    echo "üìã Ready to proceed to approval process"
                    echo "================================="
                    
                    env.PIPELINE_STATUS = "security_passed"
                    
                    // Create success report
                    writeFile(
                        file: 'SECRET_SCAN_REPORT.txt',
                        text: """
SECRET SCAN SUCCESS REPORT
=========================
Date: ${new Date()}
Branch: ${env.BRANCH_NAME}
Build: #${env.BUILD_NUMBER}
Author: ${env.COMMIT_AUTHOR}

RESULT
